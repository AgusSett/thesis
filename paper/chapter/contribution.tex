\newcommand{\const}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\bound}[1]{\AgdaBound{#1}}
\newcommand{\func}[1]{\AgdaFunction{#1}}
\newcommand{\type}[1]{\AgdaDatatype{#1}}
\newcommand{\snstar}{\type{SN*} \func{⟦\_⟧} }
\newcommand{\cand}[1]{\func{⟦}#1\func{⟧}}

\newcommand{\parens}[1]{\AgdaSymbol{(}#1\AgdaSymbol{)}}
\newcommand{\subst}[2]{\func{⟪}\AgdaSpace{}#1\AgdaSpace{}\func{⟫}\AgdaSpace{}#2}
\newcommand{\cons}[2]{#1 \func{•} #2}
\newcommand{\ids}{\func{ids}}
\newcommand{\comp}[2]{#1 \func{∘} #2}


\section{Formalización}

\subsection{Tipos intrínsecos}

Existen dos enfoques fundamentales para la introducción de sistemas de tipos en el cálculo lambda.
Por un lado, se pueden definir primero los términos y luego los tipos, por lo tanto, los términos existen independientemente de los tipos y tienen significado por sí solos.
Tiene sentido entonces definir el subconjunto de términos para los cuales existe alguna derivación de tipos, a este subconjunto se lo denomina términos ``bien tipados''.
De hecho, para un término dado pueden existir más de un tipo posible, por ejemplo, la función identidad $\lambda x.x$ puede ser tipada como $\tau \rightarrow \tau$ o como $(\tau \rightarrow \tau) \rightarrow (\tau \rightarrow \tau)$.
Desde este punto de vista, los juicios de tipado aseguran que los términos poseen ciertas propiedades.
Este estilo es llamado ``tipos a la Curry''.

Por otro lado, es posible definir los tipos en primer lugar y luego los términos.
Aquí no tiene sentido hablar de términos ``bien tipados'', ya que no pueden existir los términos ``mal tipados''.
Por lo tanto, todo el significado recae sobre los juicios de tipado, en lugar de los términos.
En cierta forma, los términos y las reglas de tipado están entrelazados.
Aquí, las derivaciones de tipos son únicas, puesto que los términos $\lambda x^\tau.x$ y $\lambda x^{\tau \rightarrow \tau}.x$ se consideran distintos.
A este enfoque se lo denomina ``tipos a la Church''.

Reynolds \cite{reynolds_1998} acuñó las expresiones \textit{tipos intrínsecos} y \textit{tipos extrínsecos} para referirse a cada uno de estos dos enfoques.

\subsection{Cálculo lambda con pares y tipo Top}

En esta sección se presenta una formalización en Agda de un cálculo lambda simplemente tipado con pares extendido con tipos isomorfismos y toda la internalización que estos implican.
Gran parte del código presentado en este trabajo está basado y adaptado a partir de un libro de Philip Wadler \cite{plfa}.
La adaptación consiste principalmente en la adición de los isomorfismos de tipos, la regla de tipado $(\equiv)$ y la relación de isomorfismos de términos.

En primera instancia se definen los tipos del lenguaje, existen cuatro constructores de tipos.
Por un lado, los tipos base son, el tipo atómico \const{$\tau$} y el tipo top \const{$\top$}.
Y, por otro lado, el tipo de las funciones \const{$\_\Rightarrow\_$} y los pares \const{$\_\times\_$}.

\begin{codigo}
	Tipo de dato de los tipos
	\input{code/type.tex}
\end{codigo}

\begin{example}
	Construcción de tipos
	\ExecuteMetaData[code/example.tex]{type}
\end{example}

Dado que se utiliza la representación de De Brujin, los entornos de tipado, simplemente se formalizan como listas de tipos.
Al contrario de las listas clásicas, los entornos se leen de derecha a izquierda.

Luego se formalizan las variables intrínsecamente tipadas, que son representadas por los índices propiamente dichos.

\begin{codigo}
	Tipo de dato de los contextos de tipado y variables intrínsecamente tipadas.
	Los argumentos escritos entre $\{\}$ son implícitos, cuando se aplican los constructores, estos argumentos se omiten y Agda se encargara de inferir los valores correspondientes.
	\ExecuteMetaData[code/context.tex]{ctx}
\end{codigo}

\begin{example}
	La proposición \bound{$\Gamma$} \const{$\ni$} \bound{A} indica que existe un tipo \bound{A} dentro del entorno \bound{$\Gamma$}.
	Los términos construidos con \const{Z} y \const{s} constituyen pruebas para dichas proposiciones.
	
	Cuando el nombre de una definición no es relevante, Agda permite omitirlo utilizando un guion bajo \func{\_}.
	
	\ExecuteMetaData[code/context.tex]{example}
\end{example}

A continuación se presentan los juicios de tipado, debido a que se utilizan tipos intrínsecos, estos también representarán a los términos del lenguaje.

\begin{codigo}
	Tipo de dato de los términos
	\input{code/term.tex}
\end{codigo}

Notar que el constructor \const{[\_]≡\_} corresponde a la regla de tipado $(\equiv)$ de Sistema I.
En el constructor \const{$\pi$} se observa otro detalle importante, además de tomar como argumento el tipo \bound{C}, toma un argumento implícito que funciona como evidencia de que el tipo \bound{C} es o bien igual al tipo \bound{A}, o bien igual al tipo \bound{B}.
Para ello se utilizan el tipo suma \type{$\_\uplus\_$} definido en el módulo \AgdaModule{Data.Sum} y la igualdad proposicional \type{$\_\cong\_$} definida en el módulo \AgdaModule{Relation.Binary.PropositionalEquality}.
Estos dos tipos forman parte de la librería estándar de Agda.
Generalmente, se utiliza el símbolo $(\equiv)$ para denotar la igualdad proposicional, pero en ese caso, ese símbolo se utilizará para definir los isomorfismos de tipos, por lo tanto, se renombra el operador de la igualdad al símbolo $(\cong)$

\begin{example}
	Construcción de términos
	\ExecuteMetaData[code/example.tex]{term}
\end{example}

Aquí se introducen las definiciones de los renombres de variables, substitución de variables y operadores del álgebra-$\sigma$ presentados en capítulos anteriores.

\ExecuteMetaData[code/subs.tex]{operators}

Los renombres son simplemente funciones que mapean las variables de un entorno a otro preservando el tipo de las mismas.
Por otro lado, las substituciones mapean cada variable de un entorno a un término que tenga el mismo tipo que dicha variable.
Se pueden pensar a estas substituciones como las secuencias de términos que se utilizarán para reemplazar las variables libres cuando se aplica dicha substitución sobre otro término. 

La implementación de las substituciones explícitas se divide en dos partes.
Primero se implementa la operación \func{rename} que dada una función de renombrado $\rho$ y un término, aplica el renombre de variables $\rho$ a dicho término.
Se debe tener cuidado de no capturar el índice 0 cuando se empuja el renombre debajo de una abstracción.
Por este motivo, se define la función \func{ext} que toma un renombre y retorna uno nuevo con los entornos extendidos.
Notar que esta definición sigue la forma propuesta por Abadi: $Z \bullet (\rho \; \circ S\_)$

\begin{codigo}
	Aplicación de renombres sobre términos
	\ExecuteMetaData[code/subs.tex]{rename}
\end{codigo}

\begin{example}
	El renombre \const{S\_} simplemente suma uno a todas las variables libres del término
	\ExecuteMetaData[code/example.tex]{rename}
\end{example}

Una vez definida la función \func{rename}, se puede implementar la aplicación de substituciones.
Para ello, se define de forma análoga, una función \func{exts} que extiende la sustitución cuando se atraviesa una abstracción.
Utilizando la notación del álgebra-$\sigma$, se puede observar que aquí también se sigue la misma estructura: $`Z \bullet (\sigma \; \circ \text{rename } S\_)$.

Luego se define la substitución simple \func{$\_[\_]$}, que dato un término \bound{N} cuya primera variable libre es de tipo \bound{B} y un término \bound{M} de tipo \bound{B}, reemplaza el índice 0 de \bound{N} utilizando \bound{M} y reduce en uno el resto de las variables libres.

\begin{codigo}
	Aplicación de substituciones sobre términos
	\ExecuteMetaData[code/subs.tex]{subst}
\end{codigo}

Notar como las definiciones de \func{rename} y \func{subst} poseen una estructura similar, esto se debe a que los renombres son un caso particular de substitución, donde todos los términos retornados por la substitución son variables.
Esta implementación está basada en la técnica de McBride\cite{ren-sub}, donde los renombres de variables y substituciones son dos instancias de una misma operación de recorrido.
El motivo principal por el cual es necesario implementar \func{rename}, es que si se quisiera definir \func{exts} utilizando \func{subst} ($\lambda$ \bound{v} $\rightarrow$ \const{`} (\const{S} \bound{v})) (\bound{$\sigma$} \bound{x}), la llamada recursiva sería sobre el término retornado por $\sigma$, de modo que el chequeo de terminación de Agda fallaría.

\begin{example}
	La substitución simple reemplaza la primera variable libre por un término del mismo tipo que dicha variable.
	Luego, el contexto del término resultante tendrá un elemento menos.
	\ExecuteMetaData[code/example.tex]{subst1}
\end{example}
\begin{example}
	Cuando se reemplaza un término con variables libres en el cuerpo de una abstracción, las mismas son renombradas para evitar que sean capturadas.
	\ExecuteMetaData[code/example.tex]{subst2}
\end{example}

Finalmente, se presenta la relación de reducción.
Los constructores \const{$\xi$} y \const{$\zeta$} representan las reglas de congruencia que permiten construir reducciones sobre subtérminos.

\begin{codigo}
	Tipo de dato de la relación de reducción
	\input{code/reduction.tex}
\end{codigo}

Es importante destacar que el tipo de \type{$\_\hookrightarrow\_$}, está indexado por dos términos del mismo tipo \bound{A}.
Por lo tanto, no es necesario demostrar que la reducción preserva tipos, ya que es imposible construir una reducción que arribe a un término de distinto tipo.
Esta es una de las ventajas más importante de utilizar tipos intrínsecos.

\begin{example}
	Las congruencias permiten construir reducciones sobre subtérminos
	\ExecuteMetaData[code/example.tex]{reduction}
\end{example}

\subsection{Isomorfismo de términos}

Los isomorfismos de tipos que se incluyen en esta formalización corresponden al conjunto axiomático $Th^1_{\times\top}$.
Además de los axiomas, se definen los constructores \const{sym} y \const{cong} que representan las simetrías y congruencias respectivamente.

\begin{codigo}
	Relación de equivalencia entre tipos isomorfos
	\input{code/iso_type.tex}
\end{codigo}
Utilizando estos constructores es posible construir cualquier isomorfismo.
Notar que no existe una regla para la transitividad, ya que es posible obtenerla aplicando dos veces el constructor \const{$[\_]\equiv\_$}.
Por ejemplo, el término \const{[ trans} \bound{$iso_1$} \bound{$iso_2$} \const{]$\equiv$} \bound{t} puede ser construido como \const{[} \bound{$iso_2$} \const{]$\equiv$} (\const{[} \bound{$iso_1$} \const{]$\equiv$} \bound{t}).

\begin{example}
	Construcción de términos utilizando isomorfismos
	\ExecuteMetaData[code/example.tex]{iso-type}
\end{example}

A continuación se presenta la formalización de la relación de simetría entre términos correspondientes de tipos isomorfos $(\rightleftarrows)$.
La selección de isomorfismos entre términos aquí presentada, es el resultado de varias decisiones de diseño basadas principalmente en dos objetivos.

En primer lugar, se agregaron todos los isomorfismos necesarios para que ningún término quede atascado y no existan eliminaciones en formas normales, esto tiene como consecuencia que todo término cerrado reduce siempre a un valor.
Este punto es más evidente cuando se tiene en cuenta la prueba de progreso presentada más adelante.

El segundo objetivo es preservar la propiedad de normalización y evitar que su prueba se torne demasiado compleja.
Una consecuencia directa de esto, son los constructores con el prefijo \const{sym-}, todos ellos se podrían obtener a partir de los isomorfismos base combinados con un constructor \const{sym} tal y como se construyen los isomorfismos de tipos.
Sin embargo, incluir el constructor \const{sym} genera problemas a la hora de formalizar la prueba de normalización fuerte.
Por otro lado, para desatascar algunos términos, es necesario incluir la $\eta$-expansión y una regla \textsc{split} $r \rightleftarrows \langle \pi_A\; r , \pi_B\; r \rangle$ donde $r: A \times B$.
Si se incluyen estas reglas directamente, se pierde la propiedad de normalización, ya que por ejemplo nada impediría aplicar la $\eta$-expansión un número infinito de veces.
La solución es definir nuevos constructores que embeban estas reglas, como por ejemplo \const{asso-split}.


\begin{codigo}
	Relación de isomorfismo de términos
	\input{code/iso_term.tex}
\end{codigo}

Al igual que en la relación de reducción, los tipos intrínsecos garantizan que los términos transformados por los isomorfismos preservan sus tipos.
Notar como todos los isomorfismos base presentan una regla ($\equiv$) del lado izquierdo, la cual desaparece del lado derecho.
Por lo tanto, los isomorfismos solo pueden aplicarse para eliminar un constructor ($\equiv$) del término.
%TODO:
Este último punto es fundamental para preservar la propiedad de normalización.


\begin{example}
	El isomorfismo de término \const{sym-dist-$\lambdabar$} distribuye la abstracción sobre el par y elimina el constructor \const{[ sym dist ]$\equiv$} del término resultante.
	Las congruencias funcionan de forma análoga a las de la relación \type{$\_\hookrightarrow\_$}
	\ExecuteMetaData[code/example.tex]{iso-term}
\end{example}

\subsection{Preservación de tipos}

Es importante destacar que la representación con tipos intrínsecos provee implícitamente la propiedad de preservación.
La relación de isomorfismo de términos \type{$\_\rightleftarrows\_$} y la relación de reducción \type{$\_\hookrightarrow\_$} solo pueden relacionar términos del mismo tipo. 
En consecuencia, no puede darse el caso en el que un término reduzca, de forma errónea, a otro de un tipo distinto.


\section{Progreso}

\subsection{Formas normales, neutrales y valores}

La propiedad de progreso dice que todo término puede o bien dar un paso de reducción, o bien se encuentra en un estado final.
Si solo se consideran términos cerrados, es decir, que no contienen variables libres, los estados finales son los valores.
Existen tres constructores para los valores: los pares de valores, las abstracciones y el término $\star$.

\begin{codigo}
	Tipo de dato de los valores
	\ExecuteMetaData[code/progress.tex]{value}
\end{codigo}

Sin embargo, en la definición de progreso que se presentará a continuación, se implementa el orden de reducción aplicativo, es decir, se deben reducir los cuerpos de las abstracciones.
Cuando se reduce debajo de las abstracciones es posible encontrar variables libres.
Cuando se trabaja con términos que pueden contener variables libres, los estados finales que se deben considerar son las formas normales.

A continuación daremos una definición inductiva de las formas normales. Un término está en forma normal si no puede ser reducido. La siguiente sintaxis caracteriza a los términos en forma normal del lenguaje dado: 
\begin{align*}
	\textbf{norm} &:= \langle \textbf{norm}, \textbf{norm} \rangle \mid \lambda x. \textbf{norm} \mid \star \mid \textbf{neu} \\
	\textbf{neu} &:= var \mid \pi\; \textbf{neu} \mid \textbf{neu} \cdot \textbf{norm} \mid [\, iso \,]\!\!\equiv \textbf{neu}
\end{align*}

Donde $var$ son las variables y la categoría sintáctica $neu$ caracteriza a las formas neutrales, que son términos que no pueden reducirse y no son valores.

\begin{codigo}
	Definición inductiva de las formas normales y neutrales
	\ExecuteMetaData[code/progress.tex]{normal}
\end{codigo}

Notar como las definiciones de \type{$\Uparrow$} y \type{$\Downarrow$} son mutuamente recursivas.

Se puede observar que en la definición de las formas neutrales, el único constructor que no es recursivo es el de las variables.
Es decir que, para poder construir una forma neutral, necesariamente se debe utilizar el caso base de la variable al menos una vez.
Por lo tanto, un término está en forma neutral solo si contiene variables libres.
Luego, es fácil ver que todo término cerrado en forma normal es un valor.

\begin{codigo}
	Todo término cerrado en forma normal es un valor
	\ExecuteMetaData[code/progress.tex]{proof}
\end{codigo}

\subsection{Estrategia de reducción}

La formalización de progreso implementa una estrategia de reducción \textit{strong call-by-value}, es decir, reduce primero los argumentos de las aplicaciones antes de aplicar la $\beta$-reducción, y además, reduce debajo de los lambdas.

Se define una nueva relación \type{Progress}, que representa los tres posibles resultados de aplicar la prueba de progreso sobre un término, estos son, dar un paso de reducción \type{$\_\hookrightarrow\_$}, aplicar un isomorfismo \type{$\_\rightleftarrows\_$}, o puede encontrarse que el término está en forma normal, en cuyo caso no es posible seguir reduciéndolo.

\begin{codigo}
	Propiedad de progreso
	\ExecuteMetaData[code/progress.tex]{progress-type}
\end{codigo}

Luego, la prueba de progreso consiste en probar que la propiedad \type{Progress} se cumple para todo término dado.

En primer lugar, se presentan los casos para las variables y el término \const{$\star$}, donde simplemente se concluye que ambos se encuentran en formal normal.

\ExecuteMetaData[code/progress.tex]{progress-base}

Para el caso de la abstracción, se realiza una llamada recursiva de \func{progress} sobre el cuerpo de la función, en caso de que esta nueva llamada retorne un paso, entonces se extiende dicho paso usando la congruencia \const{$\zeta$}.
En otro caso, se retorna que la abstracción está en forma normal.

\ExecuteMetaData[code/progress.tex]{progress-lam}

Para los pares se sigue un razonamiento análogo con la diferencia de que se realizan dos llamadas recursivas, una por cada lado del par.
Primero se realizan todos los pasos que sean posibles sobre el lado izquierdo, y luego sobre el lado derecho.

\ExecuteMetaData[code/progress.tex]{progress-prod}

Notar que las evidencias retornadas por las llamadas recursivas que indican que \bound{N} y \bound{M} están en forma normal, son utilizadas para probar que todo el par se encuentra en formal normal \const{N-$\langle$}~\bound{NN}~\const{,}~\bound{NM}~\const{$\rangle$}.

Para las proyecciones se reduce primero el término que se está proyectando.
Aquí se debe notar que existen dos posibles formas en las que la llamada recursiva puede alcanzar una forma normal.
Por un lado, podría llegar a una forma neutral, en cuyo caso toda la proyección es neutral.
Por otro lado, podría alcanzar un par en formal normal, en cuyo caso es posible proyectar dicho par.

\ExecuteMetaData[code/progress.tex]{progress-proj}

La aplicación sigue la misma lógica, solo que en este caso se reduce primero la función, luego el argumento, y, cuando ambos términos llegan a una forma normal, se aplica la $\beta$-reducción.
Sin embargo, si la función se encuentra en formal neutral, entonces no es posible realizar la aplicación, pro lo que todo el término será neutral.

\ExecuteMetaData[code/progress.tex]{progress-app}

Por último se presenta el constructor \const{[}~\bound{iso}~\const{]≡}~\bound{N}.
Al igual que en el resto de los casos, primero se reduce el subtérmino \bound{N}.
Luego, para cada forma normal se deben tener en cuenta todos los isomorfismos que sean aplicables en cada caso.

\ExecuteMetaData[code/progress.tex]{progress-iso}

Notar como solo es posible aplicar \const{step⇄ asso} cuando el elemento de la derecha es un par.
En caso de que dicho elemento esté en forma neutral, es necesario convertirlo a un par aplicando la regla $r \rightleftarrows \langle \pi_A (r), \pi_B(r) \rangle$ antes de poder aplicar \const{asso}.
Por ejemplo, para reducir el siguiente término:

\ExecuteMetaData[code/example.tex]{asso-split}

Se requiere aplicar el isomorfismo \const{asso-split} que combina ambas reglas en un solo paso:

\ExecuteMetaData[code/example.tex]{asso-split2}

Lo mismo ocurre con el resto de los isomorfismos que presentan los sufijos \const{split} y \const{$\eta$}.

Finalmente, si el término \bound{N} es neutral, se concluye que todo el término también es neutral.

La definición de \func{progress} muestra claramente como cada isomorfismo de término se corresponde con un caso donde es necesario eliminar una regla $(\equiv)$ para poder continuar con la reducción.
En la formalización, el lenguaje es dirigido por sintaxis.
Cuando se representan los términos usando tipos intrínsecos, la sintaxis del lenguaje contiene los isomorfismos de tipos.
Por lo tanto, tiene sentido que la aplicación de los isomorfismos de términos también sea dirigida por sintaxis.

Otra observación interesante es que gracias a la dualidad entre pruebas y programas que propone el paradigma de Proposiciones como Tipos, implementar y demostrar resultan ser la misma tarea.
Por lo tanto, la prueba \func{progress} es también un programa, que al ser aplicado sobre un término retorna el siguiente paso de reducción correspondiente a dicho término.

\begin{example}
	Aplicar progreso sobre un término puede tener como resultado un paso de reducción, la aplicación de un isomorfismo, o devolver evidencia de que el término ya se encuentra en forma normal
	\ExecuteMetaData[code/example.tex]{progress}
\end{example}

\section{Evaluación}

A través de la aplicación sucesiva de la prueba de progreso se puede definir la evaluación.
Para esto, se define la relación \type{$\_\rightsquigarrow\_$}, que representa la clausura reflexiva y transitiva de la unión entre las relaciones \type{$\_\hookrightarrow\_$} y \type{$\_\rightleftarrows\_$}.

\begin{codigo}
	Relación de reducción
	\ExecuteMetaData[code/eval.tex]{relation}
\end{codigo}

La evaluación se define sobre términos cerrados, de modo que estos siempre reduzcan a un valor.
La definición aplica la prueba de progreso para obtener el nuevo término sobre el cual hacer el llamado recursivo y el paso de reducción que extenderá la relación \type{$\_\rightsquigarrow\_$}.

Debido a que la recursión se realiza sobre el término resultante luego de un paso, Agda no tiene forma de determinar que dicho término es estructuralmente más pequeño que el argumento inicial.
De hecho, probar la terminación de la evaluación, implicaría que todo término reduce a un valor en una cantidad finita de pasos, es decir, se estaría probando la propiedad de normalización.
La prueba de dicha propiedad no es trivial, y se presentará en la siguiente sección.

Por este motivo, es necesario añadir un argumento de tipo \type{$\mathbb{N}$} para que la definición sea aceptada por el chequeo de terminación de Agda.
De este modo, la evaluación realizará a lo sumo $n$ llamadas recursivas.
Además, se utiliza \type{Maybe} en el tipo de retorno, en caso de que el término no converja a un valor luego de $n$ pasos, simplemente se retornará \const{nothing}.


\begin{codigo}
	Evaluación
	\ExecuteMetaData[code/eval.tex]{eval}
\end{codigo}

\begin{example}
	Cuando la cantidad de pasos máxima es suficiente, la evaluación retorna la secuencia de reducción y evidencia de que el término final es un valor
	\ExecuteMetaData[code/example.tex]{eval1}
\end{example}

\begin{example}
	En caso de que la cantidad de pasos no sea suficiente para arribar a un valor, la evaluación retorna la secuencia de reducción incompleta y el constructor \const{nothing}
	\ExecuteMetaData[code/example.tex]{eval2}
\end{example}

\section{Normalización Fuerte}

La propiedad de normalización fuerte dice que para cualquier término dado, toda secuencia de reducción eventualmente concluye, sin importar el camino elegido.
O dicho de otra forma, no es posible construir secuencias de reducción infinitas.
Se puede codificar esta propiedad definiendo un tipo de datos que predique sobre los términos del lenguaje.

\begin{codigo}
	Propiedad de normalización fuerte
	\ExecuteMetaData[code/strong_norm.tex]{SN}
\end{codigo}

Notar que es trivial construir un término de tipo \type{SN} para un valor, ya que, al no existir ninguna reducción posible para los valores, simplemente se debe pasar la función vacía como argumento a \const{sn}.
Estos representan los casos bases del tipo \type{SN}.

\begin{example}
	Cuando se construye \type{SN} se deben tener en cuenta todos los pasos de reducción posible.
	Para términos normales, todos los pasos concluyen en un patrón absurdo.
	En los casos que si es posible aplicar una eliminación, se debe construir recursivamente \type{SN} para el término resultante.
	
	\ExecuteMetaData[code/example.tex]{sn}
\end{example}

El hecho de que exista un término de tipo \type{SN} \bound{t} implica que no existen secuencias de reducción infinitas a partir de \bound{t}, de otro modo, no hubiera sido posible construir dicho término.
El objetivo final de esta sección será entonces, definir una función que dado un término cualquiera, permita obtener un término de tipo \type{SN} \bound{t}:

\vspace{0.5em}
\func{strong-norm}
\AgdaSymbol{:}
\AgdaSymbol{∀}
\AgdaSymbol{\{}\bound{Γ}
\bound{A}\AgdaSymbol{\}}
\AgdaSymbol{(}\bound{t}
\AgdaSymbol{:}
\bound{Γ}
\type{⊢}
\bound{A}\AgdaSymbol{)}
\AgdaSymbol{→}
\type{SN}
\bound{t}
\vspace{0.5em}

La prueba aquí presentada está basada y extendida a partir de una formalización realizada por 
Andras Kovacs\footnote{\citeurl{Kovacs}} para cálculo lambda simplemente tipado.
A su vez, el trabajo de Kovacs se basa en la tesis de Steven Schäfer \cite{Schafer}, donde se formaliza la prueba de normalización fuerte para Sistema-F en Coq.
La técnica utilizada por Schäfer difiere en ciertos aspectos con la prueba de candidatos de reducibilidad de Girard \cite{Girard}.
Además, se utilizó como referencia una formalización de candidatos de reducibilidad en Agda realizada por Pablo Barenbaum\footnote{\citeurl{Barenbaum}}.

\subsection{Prueba para STLC con pares y Top}

Con el objetivo de facilitar la comprensión de la prueba, la misma será presentada en dos partes.
En esta sección se explicará la prueba para cálculo lambda simplemente tipado con pares, es decir, sin incluir la relación de isomorfismos entre términos.
Y en la siguiente sección se presentarán los cambios necesarios para extender la prueba a Sistema-I.


Por lo tanto, se define el predicado \type{SN} utilizando solo la relación \type{$\_\hookrightarrow\_$}

\ExecuteMetaData[code/strong_norm_base.tex]{sn}

La idea de la prueba es definir una generalización del tipo \type{SN} que añade un predicado sobre el término \bound{$t$}.
Como se explicará más adelante, el objetivo de este predicado es añadir información extra sobre el término cuando se construyen las introducciones, y luego usar esa información cuando se prueban los casos de las eliminaciones.

\ExecuteMetaData[code/strong_norm_base.tex]{sn-star}

Luego, se define lo que se denomina \textit{interpretación del término}.

\ExecuteMetaData[code/strong_norm_base.tex]{candidate}

La definición utiliza los productos \func{$\_\times\_$} y el tipo top \type{$\top$} definidos en los módulos \AgdaModule{Data.Product} y \AgdaModule{Data.Unit} de la librería estándar.
Para evitar una colisión de nombres con los constructores de tipos del cálculo, se renombran los tipos de la librería estándar como \func{$\_\otimes\_$} y \type{Top} respectivamente.

Es fácil ver que si un término cumple con el predicado \type{SN*} también cumple con \type{SN}

\ExecuteMetaData[code/strong_norm_base.tex]{sn-star-sn}

La definición de la interpretación de los términos se extiende a las substituciones.
Se dice que una substitución es adecuada cuando todos los términos por los cuales substituye las variables, cumplen con el predicado \snstar

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-subst}

En particular, la substitución identidad \func{ids} es una substitución adecuada

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-var}
\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-ids}

Toda la complejidad de la prueba se centra en probar el teorema fundamental, el cual implica que para todo término \bound{t} y substitución adecuada \bound{σ} se cumple
\snstar\parens{\subst{\bound{σ}}{\bound{t}}}

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-type}

\subsubsection{Caso variable}

Este caso requiere que la substitución $\sigma$ aplicada a la variable $v$ cumpla con la propiedad
\snstar.
La hipótesis dice que $\sigma$ es una substitución adecuada, por lo tanto, basta con simplemente aplicar dicha hipótesis a la variable $v$.

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-var}

\subsubsection{Caso top}

Debido a que no existe ningún paso de reducción posible para el término \const{$\star$}, la construcción del predicado es trivial.

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-top}
\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-top}

\subsubsection{Caso producto}

Para el caso del producto, se puede definir un lema que permite construir el predicado si se tiene como hipótesis que \snstar vale para los subtérminos $a$ y $b$ del par.
Estas dos hipótesis son necesarias para obtener \snstar \bound{a'} y \snstar \bound{b'} a partir de cada uno de los dos pasos de reducción de congruencia.

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-prod}

Luego, se utiliza la hipótesis inductiva en \func{adecuacy} sobre $a$ y $b$ para instanciar el lema

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-pair}

\subsubsection{Caso proyección}

El caso de la proyección también requiere como hipótesis que se cumpla el predicado para el término que se está proyectando.
Los pasos de reducción \const{β-π₁} y \const{β-π₂} implican que $t$ tiene forma $\langle a, b \rangle$, estos requieren obtener \snstar \bound{a} y \snstar \bound{b} respectivamente.
El problema es que no se puede concluir nada sobre $a$ y $b$ a partir de \bound{SNt}.
Aquí se vuelve evidente porque es necesario generalizar la propiedad \type{SN} y añadir la interpretación del término.
La interpretación de un par $\langle a, b \rangle$ tiene forma \snstar\bound{a} \func{⊗} \snstar\bound{b} y esto es precisamente lo que necesitamos probar en ambos casos.

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-proj}
\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-proj}

\subsubsection{Caso aplicación}

Este caso es similar al producto, ya que la hipótesis del lema requiere que el predicado se cumpla para ambos subtérminos.
Por otro lado, la solución para el caso de la $\beta$-reducción es similar al caso de la proyección, puesto que se utiliza la interpretación de la abstracción.
Para el constructor \const{β-ƛ}, el término $a$ es de la forma $\lambda\; t$, por lo que se debe obtener
\snstar(\bound{t}\func{[}\bound{b}\func{]}).

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-app}
\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-app}

La interpretación \bound{La} será de la forma
\snstar\bound{u}
\AgdaSymbol{→}
\snstar\parens{\subst{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}{\bound{t}}}
es decir que basta con aplicar dicha función a \bound{SN*b}.

Notar como las interpretaciones de los términos permiten resolver los casos de eliminación (proyección y aplicación), pero, por otro lado, los casos de introducción (producto y abstracción) se vuelven más complejos, ya que son estos donde se construyen dichas interpretaciones.
Esta construcción es simple para los productos, puesto que se puede deducir de forma directa aplicando la hipótesis inductiva en \func{adecuacy}.	
Sin embargo, como se verá más adelante, obtener la interpretación correspondiente al caso de las abstracciones, resulta particularmente complejo.

\subsubsection{Caso isomorfismo}

Este caso no presenta mayores dificultades. Sin embargo, la mayor parte de la complejidad para la extensión de la prueba a Sistema-I, se encuentra al añadir todos los constructores de isomorfismos de términos a este lema.

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-iso}
\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-iso}

\subsubsection{Caso abstracción}

La prueba del lema para el caso de la abstracción requiere obtener la interpretación \cand{ \const{ƛ} \bound{t'} } en la llamada inductiva.
Para ello es necesario definir un nuevo lema que permite conjugar un paso de reducción con cualquier substitución.

\ExecuteMetaData[code/strong_norm_base.tex]{reduction-subst}

A su vez, la prueba de dicho lema requiere una propiedad de la substitución para poder probar el caso correspondiente a la $\beta$-reducción.
La propiedad \func{subst-commute} dice que la substitución conmuta consigo misma:

\ExecuteMetaData[code/strong_norm_base.tex]{subst-commute}

Luego se utiliza la hipótesis \bound{Lƛ} en conjunto con el nuevo lema.

\ExecuteMetaData[code/strong_norm_base.tex]{lemma-abs}

La instanciación de las hipótesis necesarias para utilizar el lema en la prueba de \func{adecuacy} requiere especial atención.

Por un lado, para obtener la hipótesis \snstar \bound{t}, primero se debe probar que la extensión de una substitución adecuada sigue siendo adecuada.

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-exts}

A su vez, para esta prueba es necesario demostrar que si se aplica un renombre de variables a un término \snstar este no perderá dicha propiedad, esto tiene sentido, ya que los renombres no alteran el significado de los términos y, por lo tanto, preservan la propiedad \snstar

\ExecuteMetaData[code/strong_norm_base.tex]{sn-rename}

Aquí se deben realizar dos observaciones importantes.
En primer lugar, el caso de la abstracción en la prueba de \func{⟦⟧-rename} es el único lugar donde es necesario usar el argumento $\rho$ de la interpretación.
De hecho, este es precisamente el motivo por el cual es necesario generalizar la interpretación de las lambdas añadiendo un renombre en su definición.

En segundo lugar, en la prueba de \func{SN*-rename} se debe eliminar el renombre del paso de reducción para poder utilizar la hipótesis \bound{SNt}.
Para ello se define el siguiente lema:

\ExecuteMetaData[code/strong_norm_base.tex]{rename-reduction-type}

Básicamente, el lema dice que si una reducción parte de un término renombrado $t_\rho$, el resultado será un término $t'_\rho$, donde $t'$ se obtiene dando un paso de reducción desde $t$.


Por otro lado, para obtener la interpretación \cand{ \const{ƛ} \bound{t'} } se necesita demostrar dos propiedades más sobre las substituciones adecuadas.

Una de ella dice que una substitución adecuada compuesta con un renombre, es también una substitución adecuada.
La prueba utiliza el hecho de que \func{rename} \bound{ρ} puede ser escrito como
\subst{\comp{\ids}{\bound{$\rho$}}}{}

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-rename}

La otra propiedad, dice que el cons entre un término \snstar y una substitución adecuada, es también una substitución adecuada.

\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-cons}

Un último detalle a destacar es que \func{adecuacy} toma como argumento solo una substitución, por lo que se debe combinar \bound{$\sigma$} y
\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}
en una sola substitución y demostrar que aplicar dicha combinación es equivalente a aplicarlas por separado.

\ExecuteMetaData[code/strong_norm_base.tex]{subst-split}

%\ExecuteMetaData[code/strong_norm_base.tex]{subst-split-simple}

\begin{samepage}
	\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy-abs}
\end{samepage}

%\ExecuteMetaData[code/strong_norm_base.tex]{adecuacy}
La función \func{transport} permite obtener \bound{P y} a partir de una prueba de \bound{x} \type{$\cong$} \bound{y} y una instancia de \bound{P x}.
Esto es útil cuando se tiene como hipótesis \snstar \bound{x} y se debe concluir \snstar \bound{y}, en dicho caso simplemente se utiliza \func{transport} con una prueba de que \bound{x} y \bound{y} son equivalentes.
Esta función está definida en el módulo \AgdaModule{Relation.Binary.PropositionalEquality} con el nombre \func{subst}, aquí se la renombra a \func{transport} para evitar una colisión de nombres con la substitución.

\subsubsection{Cierre de la prueba}

Finalmente, se prueba la propiedad de normalización fuerte instanciando \func{adecuacy} con la substitución identidad.

Como detalle adicional, se elimina la substitución identidad aplicada al término utilizando el lema
\func{sub-id}
\AgdaSymbol{:}
\AgdaSymbol{∀\{}\bound{Γ}
\bound{A}\AgdaSymbol{\}}
\AgdaSymbol{\{}\bound{N}
\AgdaSymbol{:}
\bound{Γ}
\type{⊢}
\bound{A}\AgdaSymbol{\}}
\AgdaSymbol{→}
\subst{\ids}{\bound{N}}
\type{≡}
\bound{N}

\ExecuteMetaData[code/strong_norm_base.tex]{strong-norm}


\subsection{Prueba para Sistema I con tipo Top}

El primer paso para extender la prueba, es agregar en la definición de \type{SN}, la relación de isomorfismos entre términos.

\ExecuteMetaData[code/strong_norm.tex]{SN}
\ExecuteMetaData[code/strong_norm.tex]{sn-star}

Este cambio tiene como consecuencia que todas las partes de la prueba que construían un término \snstar haciendo \textit{pattern matching} sobre la relación $\hookrightarrow$, ahora deberán tener también en cuenta los constructores de la relación $\rightleftarrows$ que sean aplicables en cada caso.

Por ejemplo, en la prueba de \func{SN*-rename} ahora aparecen los dos constructores \const{inj₁} y \const{inj₂} del tipo suma.

\ExecuteMetaData[code/strong_norm.tex]{sn-rename}

Para esta prueba es necesario definir un nuevo lema análogo a \func{rename↪}.

\ExecuteMetaData[code/strong_norm.tex]{rename-iso-type}

Una modificación similar se realiza para extender el lema de la abstracción.

\ExecuteMetaData[code/strong_norm.tex]{lemma-abs}

Este caso también requiere la definición de un nuevo lema análogo al definido para la relación $\hookrightarrow$ anteriormente.

\ExecuteMetaData[code/strong_norm.tex]{iso-subst}

La extensión del resto de los lemas no presentan mayores dificultades.
A modo de ejemplo se presenta el lema correspondiente al producto, y se omiten los demás.

\ExecuteMetaData[code/strong_norm.tex]{lemma-prod}

El lema para el constructor de isomorfismos es donde se concentra la mayor complejidad de la prueba, ya que se deben resolver los casos de todos los isomorfismos de términos.
Para empezar, se presentan las reglas de congruencia.

\ExecuteMetaData[code/strong_norm.tex]{lemma-iso-type}

Luego, el objetivo para cada constructor será obtener \snstar\bound{t'} a partir de \snstar\bound{t}, donde \bound{t} y \bound{t'} son los términos relacionados por el isomorfismo correspondiente.
La idea de la prueba es utilizar los lemas anteriormente definidos para los distintos constructores de términos.

\subsubsection{Caso comm}

Por ejemplo, el isomorfismo \textsc{comm} es uno de los casos más simples que ilustra la técnica utilizada.
Aquí simplemente basta con instanciar el lema del producto utilizando las hipótesis provistas por la interpretación del par.

\ExecuteMetaData[code/strong_norm.tex]{iso-comm}

\subsubsection{Caso asso}

El caso de \textsc{asso} no tiene mayor dificultad.
Notar como se aprovecha la naturaleza constructiva de las pruebas en Agda, combinando los lemas ya definidos hasta obtener un término del tipo esperado.

\ExecuteMetaData[code/strong_norm.tex]{iso-asso}

\subsubsection{Caso dist}

Este caso presenta la dificultad de instanciar y construir la interpretación de la abstracción.
Además, se presentan dos nuevos lemas que se emplearán en múltiples isomorfismos.
En primer lugar, se define un lema que permite concluir \snstar\bound{t} a partir de \snstar \const{ƛ} \bound{t}.
La idea del lema es utilizar \bound{Lt} para obtener
\subst{\cons{\const{` Z}}{\const{S\_}}}{\bound{t}}, es decir, se substituye la primera variable del término por el índice cero, por lo tanto, se obtiene exactamente el mismo término.


\ExecuteMetaData[code/strong_norm.tex]{lemma-sub}

Este lema resulta de utilidad en los casos en los que se debe construir algo a partir del cuerpo de una abstracción.

\ExecuteMetaData[code/strong_norm.tex]{iso-dist}

En segundo lugar, se define un lema que se empleará para probar la propiedad de la interpretación de la abstracción, en los casos donde se deba $\eta$-expandir un término.
La clave de este lema está en notar que 
\subst{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}{\parens{\func{rename} \const{S\_} \bound{t}}}
es equivalente a \subst{\comp{\ids}{\bound{$\rho$}}}{\bound{t}} que a su vez es equivalente a \func{rename} \bound{$\rho$} \bound{t}

\ExecuteMetaData[code/strong_norm.tex]{lemma-S}

\ExecuteMetaData[code/strong_norm.tex]{iso-distlr}

\subsubsection{Caso congruencia abstracción}

El siguiente caso presenta un isomorfismo donde aparece una substitución en el término de la derecha.
Coloquialmente, la substitución \func{σ-cong⇒₁} reemplaza el primer índice del término por
\const{[} \bound{iso} \const{]≡} \parens{\const{` Z}}
y deja el resto de los índices intactos.
La hipótesis \bound{Lt} permite obtener un término de la forma
\snstar
\parens{\subst{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}{\bound{t}}}
, entonces, la estrategia será hallar un renombre $\rho$ y un término $u$ que den como resultado el término esperado en cada caso.

Para instanciar el lema de la abstracción, las dos hipótesis requeridas en este caso son:

\vspace{1em}
\snstar
\parens{\subst
	{\cons
		{\bound{u}}
		{\parens{\comp{\ids}{\bound{$\rho$}}}}}
	{\parens{\subst
		{\cons
			{\const{[} \bound{iso} \const{]≡} \parens{\const{` Z}}}
			{\parens{\comp{\ids}{\const{S\_}}}}}
		{\bound{t}}}}}

\snstar
\subst
{\cons
	{\const{[} \bound{iso} \const{]≡} \parens{\const{` Z}}}
	{\parens{\comp{\ids}{\const{S\_}}}}}
{\bound{t}}
\vspace{1em}

La segunda es la más sencilla, ya que se puede concluir directamente a partir de \bound{Lt}.
Por otro lado, para resolver la primera, se debe notar que es posible combinar las dos substituciones en una sola 
\subst
{\cons
	{\const{[} \bound{iso} \const{]≡} \bound{u}}
	{\parens{\comp{\ids}{\bound{$\rho$}}}}}
{\bound{t}}

\ExecuteMetaData[code/strong_norm.tex]{iso-cong-lam1}

Es importante entender como se pueden combinar múltiples substituciones en una sola, que pueda ser obtenida a través de la interpretación de la abstracción.
Esta técnica será la clave para resolver los constructores correspondientes al isomorfismo \textsc{curry}, los cuales también presentan substituciones.

\subsubsection{Caso curry}

La estrategia para los dos constructores correspondientes a este isomorfismo será, en primer lugar, definir un lema que pruebe la primera hipótesis de \func{lemma-ƛ}, y luego aprovechar el hecho de que
\subst{\cons{\const{` Z}}{\comp{\ids}{\const{S\_}}}}{\bound{t}} \type{≡} \bound{t}
para concluir la segunda hipótesis.

El constructor \const{curry} tiene la particularidad de que la interpretación de su hipótesis tiene la forma 
\cand{ \const{ƛ} \const{ƛ} \bound{t} }
, por lo tanto, instanciandola una vez se puede obtener una segunda interpretación de la forma
\cand{ \const{ƛ}
\parens{\subst{\func{exts} \parens{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}}{\bound{t}}} }
la cual puede ser nuevamente instanciada para obtener
\subst{\cons{\bound{u₁}}{\parens{\comp{\ids}{\bound{$\rho_1$}}}}}{\parens{\subst{\func{exts} \parens{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}}{\bound{t}}}}

Por otro lado, se debe notar que es posible reescribir el objetivo del lema de una forma equivalente
\subst
{\cons{\const{π} \bound{B} \AgdaSymbol{\{}\const{inj₂} \const{refl}\AgdaSymbol{\}} \bound{u}}{\ids}}
{\parens{\subst
		{\func{exts} \parens{\cons
				{\const{π} \bound{A} \AgdaSymbol{\{}\const{inj₁} \const{refl}\AgdaSymbol{\}} \bound{u}}
				{\comp{\ids}{\bound{ρ}}}}}
		{\bound{t}}}}.
Es posible obtener esta forma utilizando la interpretación presentada en el párrafo anterior.

\ExecuteMetaData[code/strong_norm.tex]{lemma-curry}
\ExecuteMetaData[code/strong_norm.tex]{iso-curry}

Para el caso \const{uncurry} se debe realizar, en cierta forma, un razonamiento opuesto.
Si en el caso anterior se utilizaron dos hipótesis anidadas para instanciar un solo \func{lemma-ƛ}, en este caso se utilizará una sola hipótesis para instanciar dos \func{lemma-ƛ} anidados.

El primer lema requiere obtener
\subst
{\func{exts} \parens{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}}
{\parens{\subst{\func{σ-uncurry}}{\bound{t}}}}
mientras que el lema anidado requiere
\subst
{\cons{\bound{$u_2$}}{\parens{\comp{\ids}{\bound{$\rho_2$}}}}}
{\parens{\subst
		{\func{exts} \parens{\cons{\bound{u}}{\parens{\comp{\ids}{\bound{$\rho$}}}}}}
		{\parens{\subst{\func{σ-uncurry}}{\bound{t}}}}}}.
Aquí es donde se debe hallar una substitución equivalente que pueda ser obtenida a través de la interpretación de la abstracción.
Notar que la primera substitución aplicada es extendida, por lo que primero se reemplaza el segundo índice por el término $u$.
Luego, se substituye el primer índice por el término $u_2$ y se aplica el renombre $\rho_2$, por lo que $u$ será renombrado.
Por lo tanto, la substitución equivalente es
\subst{\cons{\const{⟨} \func{rename} \bound{$\rho_2$} \bound{$u$} \const{,} \bound{$u_2$} \const{⟩}}{\comp{\ids}{\comp{\bound{$\rho_2$}}{\bound{$\rho$}}}}}{\bound{t}}


\ExecuteMetaData[code/strong_norm.tex]{lemma-uncurry}
\ExecuteMetaData[code/strong_norm.tex]{iso-uncurry}

El resto de isomorfismos se omiten, ya que se resuelven aplicando las mismas técnicas que en los casos anteriores.

%\subsubsection{Resto de casos}

%\ExecuteMetaData[code/strong_norm.tex]{iso-sym-dist}
%\ExecuteMetaData[code/strong_norm.tex]{iso-id-prod}
%\ExecuteMetaData[code/strong_norm.tex]{iso-id-lam}
%\ExecuteMetaData[code/strong_norm.tex]{iso-abs}
%\ExecuteMetaData[code/strong_norm.tex]{iso-sym}

%\ExecuteMetaData[code/strong_norm.tex]{iso-cong-prod1}
%\ExecuteMetaData[code/strong_norm.tex]{iso-cong-prod2}

%\ExecuteMetaData[code/strong_norm.tex]{iso-cong-lam2}

%\subsection{Observaciones}
% Capitulo 5.6 como referencia
% https://www.ps.uni-saarland.de/~schaefer/thesis/draft-screen.pdf

\subsection{Relación bien fundada}

Una vez demostrada la propiedad de normalización fuerte, se puede definir la función de evaluación sin necesidad de utilizar un argumento extra para eludir el chequeo de terminación de Agda.
  
\begin{codigo}
	Evaluación de un término
	\ExecuteMetaData[code/eval.tex]{eval2}
\end{codigo}

Notar que ya no aparece \type{Maybe} en el tipo de retorno, puesto que se ha probado que toda reducción eventualmente concluye.
Aquí la llamada recursiva elimina un constructor \const{sn} del segundo argumento, por lo tanto, dicho argumento se hace estructuralmente más pequeño en cada llamada.
De esta forma, Agda puede garantizar que la función alcanzará un caso base y la recursión concluirá eventualmente.

\begin{example}
	~\newline
	\ExecuteMetaData[code/example.tex]{eval}
\end{example}

La forma en la que se codifica la propiedad de normalización fuerte, y el hecho de que sea justamente esta propiedad la que nos permite realizar inducción sobre la relación $\rightsquigarrow$, no son casualidad.
Para entender los fundamentos que se esconden detrás de estas observaciones se presentan las siguientes definiciones.

En teoría del orden, se dice que una relación está bien fundada cuando todas sus cadenas, de la forma $x_1 < x_2 < \dots < x_n$, tienen un largo acotado.
Esta propiedad se denomina accesibilidad de un elemento.

\begin{codigo}
	Accesibilidad de un término $x$ en la relación $\_<\_$
	\ExecuteMetaData[code/eval.tex]{acc}
\end{codigo}

Un elemento $x: A$ es accesible, si todo elemento $y < x$ es también accesible.
Luego, una relación está bien fundada si todo elemento es accesible.

\begin{codigo}
	Relación bien fundada
	\ExecuteMetaData[code/eval.tex]{wf}
\end{codigo}

Una relación bien fundada soporta inducción, y en el contexto de los sistemas de reescritura, cumple con la propiedad de terminación.
De hecho, la propiedad de normalización fuerte implica que la relación de reducción está bien fundada, y por lo tanto, soporta inducción.
Se puede demostrar de forma sencilla esta implicancia.

\begin{codigo}
	Normalización fuerte permite concluir que la relación $\rightsquigarrow$ está bien fundada
	\ExecuteMetaData[code/eval.tex]{wf-reduction}
\end{codigo} 
