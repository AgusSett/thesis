\documentclass[]{report}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage[style=alphabetic]{biblatex}
\addbibresource{references.bib}
\setlength{\headheight}{13.07225pt}

%opening
\title{Formalización de Sistema I con tipo Top}
\author{Agustin Settimo}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}

\end{abstract}


\chapter{Introducción}

Los sistemas de tipos permiten especificar el comportamiento de los programas. Por ejemplo, el tipo $(A \times B) \rightarrow C$ representa los programas que permiten obtener un valor de tipo $C$ a partir de un par de valores de tipo $A$ y $B$. Por otro lado, el tipo $A \rightarrow B \rightarrow C$ representa los programas que primero acepta un valor de tipo $A$, luego uno de tipo $B$ y finalmente devuelve un valor de tipo $C$. Estas dos especificaciones son distintas en su forma pero parecen tener el mismo significado semántico. Esto se debe al isomorfismo de Curry.

Debido a la estrecha relación entre la programación y la lógica, se observa un comportamiento análogo cuando se trabaja con pruebas. Por ejemplo, una prueba de $(A \wedge B) \Rightarrow C$ no constituye una prueba de $A \Rightarrow B \Rightarrow C$, y viceversa, a pesar de que ambas tienen el mismo significado.

\section{Motivación}

Tanto los sistemas de tipos como los sistemas de pruebas distinguen elementos que tienen diferente forma aunque tengan el mismo significado, como pueden ser las pruebas de las conjunciones $A \wedge B$ y $B \wedge A$, por lo cual una prueba de una no constituye una prueba de la otra, a pesar de que se puede demostrar mediante la existencia de un isomorfismo que dichas proposiciones son equivalentes.

Programas con tipos isomorfos representan el mismo tipo de problema, por lo que tratarlos como si fueran idénticos tiene aplicaciones interesantes. Por ejemplo, desde el punto de vista de los programas, nos permite construir expresiones de formas que antes eran erróneas, un término $f : (A \wedge B) \Rightarrow C$ puede ser combinado como $f \langle a, b \rangle$ ó $f \: a \: b$, es decir, es posible sortear cierta rigidez impuesta por el sistema de tipos.
Por otro lado, los isomorfismos hacen que las pruebas sean más naturales, por ejemplo, para probar, $A \wedge (A \Rightarrow  B) \Rightarrow B$, deberíamos primero introducir la hipótesis $A \wedge A \Rightarrow  B$, y luego descomponerla en $A$ y $A \Rightarrow B$, en cambio utilizando el isomorfismo de curry transformamos el objetivo en $(A \Rightarrow A \Rightarrow  B) \Rightarrow B$ y luego introducimos directamente las hipótesis $A$ y $A \Rightarrow B$.

\section{Estado del arte}
\subsection{Isomorfismos de tipos}

Para poder abstraernos de la forma y centrarnos en el significado de los
programas, es necesario establecer cuáles son las formas que son combinables
y cómo combinarlas. Para ello nos valdremos de la noción de isomorfismo
entre tipos. El primer paso es considerar dos proposiciones $A$ y $B$ como isomorfas si existen dos pruebas $A \Rightarrow B$ y $B \Rightarrow A$, tal que al componerlas, en ambos sentidos, obtenemos como resultado la identidad. Di Cosmo \cite{dicosmo} caracterizó los conjuntos mínimos de isomorfismos que permiten construir todos los demás.

% mostrar tabla de isos

\subsection{Sistema I}
% explicar lo que es, corresponde a Th1
% mostrar isos de termino y reglas de tipado

\subsection{SIP}
% explicar lo que es, corresponde a Th2

\subsection{$\lambda^+$}
% explicar que introduce el split, es necesario agregar o eliminar isos para lograr la reduccion 

\section{Estructura del trabajo}

\chapter{Preliminares}

\section{Intuitionistic Type Theory}
\section{Tipos dependientes}
\subsection{Lambda cube}
\section{Propositions as Types}
\section{Agda}
\section{Representación nameless De Bruijn}
\section{Substituciones explicitas}
[Explicit Substitutions](http://pauillac.inria.fr/~levy/pubs/90popljfp.pdf)


\chapter{Aportes}
\section{Formalización}
\subsection{Tipos intrínsecos}
Explicar la diferencia entre Curry style y Church style, y como nos ayuda tener tipos intrínsecos. Acá hay muchas referencias [https://plfa.github.io/DeBruijn/] (https://plfa.github.io/DeBruijn/).
\subsection{STLC con pares y top}
Formalizar tipos, términos y relación de reducción.
\subsection{Isomorfismo de términos}
Explicar los isos nuevos que voy a agregar. Formalizar iso tipos y relación de iso.

\subsection{Preservación de tipos}

\section{Progreso}

\subsection{Formas normales, neutrales y valores}
\subsection{Relación de reducción}

\section{Normalización Fuerte}

\subsection{Prueba para STLC con pares y top}
Primero mostrar la prueba sin isomorfismos. Puedo y extendiéndola de a poco como en el apunte de Beta Ziliani
\subsection{Diferencias con la prueba de Girard}
Capitulo 5.6 como referencia

[https://www.ps.uni-saarland.de/~schaefer/thesis/draft-screen.pdf] 

(https://www.ps.uni-saarland.de/~schaefer/thesis/draft-screen.pdf)
\subsection{Prueba para Sistema I}
\subsection{Well-founded \& Accessibility}
Explicar que lo que hicimos en realidad es probar que la inducción sobre la relación de reducción está bien fundada [https://agdapad.quasicoherent.io/~AgdaPadova/html/transcript10.html] (https://agdapad.quasicoherent.io/~AgdaPadova/html/transcript10.html). Mostrar eval.

\section{Conclusiones}


\section{Trabajo futuro}
\subsection{Inferencia de tipos}
\subsection{Formalizar SIP}


\printbibliography

\end{document}
