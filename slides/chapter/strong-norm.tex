
\begin{frame}{Normalización Fuerte}
	\begin{block}{Definición (SN)}
		Un término $s$ es fuertemente normalizante si todos sus reductos también lo son:

		\centering
		\begin{prooftree}
			\hypo{ \forall t. s \hookrightarrow t \implies t \in SN }
			\infer1{ s \in SN }
		\end{prooftree}
	\end{block}
	
	\pause
	
	\ExecuteMetaData[code/SN1.tex]{sn-def}
	
	%\ExecuteMetaData[code/SN3.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Ejemplos}
	\ExecuteMetaData[code/example.tex]{sn-1}
	\pause
	\ExecuteMetaData[code/example.tex]{sn-2}
	\pause
	\ExecuteMetaData[code/example.tex]{sn-3}
\end{frame}

\begin{frame}{Approach 1}
	Realizamos inducción directa sobre los términos:
	\begin{AgdaSuppressSpace}
		\ExecuteMetaData[code/SN1.tex]{strong-type}
		
		\pause
		
		\ExecuteMetaData[code/SN1.tex]{strong-proof}
	\end{AgdaSuppressSpace}
	
	Por H.I. sabemos que $SN$ vale para los subterminos...
	\pause
	
	Definimos algunos lemas para construir $SN$ para todo el término.
\end{frame}

\begin{frame}{Approach 1}
	Definimos una función auxiliar para realizar \textit{pattern matching} sobre el paso de reducción:
	
	\ExecuteMetaData[code/SN1.tex]{lemma-abs}
\end{frame}

\begin{frame}{Approach 1}
	\ExecuteMetaData[code/SN1.tex]{lemma-app}
	\pause
	No podemos concluir nada sobre $t[b]$, de hecho la substitución podría crear nuevos redexes dentro de $t$.
\end{frame}

\begin{frame}{Approach 1}
	El lema de introducción del par es simple...
	\ExecuteMetaData[code/SN1.tex]{lemma-prod}
\end{frame}

\begin{frame}{Approach 1}
	Pero la eliminación también da problemas:
	\ExecuteMetaData[code/SN1.tex]{lemma-proj}
\end{frame}

\begin{frame}{Approach 2}
	Definimos un $SN$ más general que añade un predicado sobre el término:
	\ExecuteMetaData[code/SN2.tex]{sn-star}
	\pause
	Es fácil ver que $SN^*$ implica $SN$:
	\ExecuteMetaData[code/SN2.tex]{sn-star-sn}
	\pause
	Luego definimos la \textbf{interpretación del término}:
	\ExecuteMetaData[code/SN2.tex]{inter}
	
	% La definición de la interpretacíon en un ttérmino particular refleja la estructura lógica de ese término de forma apropiada.
\end{frame}

\begin{frame}{Approach 2}
	La prueba queda divida en dos pasos.
	\pause
	Primero se prueba el teorema fundamental:
	\ExecuteMetaData[code/SN2.tex]{adequacy-type}
	
	\pause
	Luego es fácil probar $SN$:
	\ExecuteMetaData[code/SN2.tex]{strong-proof}
\end{frame}

\begin{frame}{Approach 2}
	\ExecuteMetaData[code/SN2.tex]{lemma-app}
	La interpretación de la abstracción es precisamente lo que permite probar el caso de la aplicación.
	\pause
	Del mismo modo, la interpretación del par resuelve el caso de la proyección.
	\ExecuteMetaData[code/SN2.tex]{lemma-proj}
\end{frame}

\begin{frame}{Approach 2}
	\ExecuteMetaData[code/SN2.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Approach 3}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{\draw[red,thick,rounded corners] (7.44361, 6.4) rectangle (10.16, 5.9);}
		\only<2>{\draw[red,thick,rounded corners] (11.9592, 6.4) rectangle (12.8411, 5.9);}
	\end{tikzpicture}

	Generalizamos el teorema fundamental, vamos a probar que vale para cualquier $t$ con cualquier substitución aplicada:
	\ExecuteMetaData[code/SN3.tex]{adequacy-type}
	\pause[3]
	\ExecuteMetaData[code/SN3.tex]{strong-proof}
\end{frame}


\begin{frame}{Approach 3}
	\ExecuteMetaData[code/SN3.tex]{subst-split}
	
	\ExecuteMetaData[code/SN3.tex]{adequacy-proof}
	\pause
	Ahora el problema está en el caso de las variables, una substitución arbitraria podría ``romper'' el término.
\end{frame}

\begin{frame}{Approach 4}
	Definimos las \textbf{substituciones adecuadas}:
	\ExecuteMetaData[code/SN4.tex]{adequacy-subst}
	\pause
	En particular $ids$ es adecuada:
	\ExecuteMetaData[code/SN4.tex]{adequacy-ids}
	\pause
	El cons entre un término $SN$ y una subst. adecuada, también es adecuada:
	\ExecuteMetaData[code/SN4.tex]{adequacy-cons}
	\pause
	Nuevamente fortalecemos el teorema:
	\ExecuteMetaData[code/SN4.tex]{adequacy-type}
\end{frame}

\begin{frame}{Approach 4}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<3>{\draw[red,thick,rounded corners] (3.77472, 4.72) rectangle (5.60917, 4.35);}
	\end{tikzpicture}
	
	\ExecuteMetaData[code/SN4.tex]{adequacy-proof}
	\pause
	\ExecuteMetaData[code/SN4.tex]{strong-proof}
\end{frame}

\begin{frame}{Approach 4}
	\ExecuteMetaData[code/SN4.tex]{adequacy-exts}
	\pause
	\ExecuteMetaData[code/SN4.tex]{sn-rename}
	\pause
	\ExecuteMetaData[code/SN4.tex]{inter-rename}
\end{frame}

\begin{frame}{Approach 5}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{\draw[red,thick,rounded corners] (8.64306, 6.92168) rectangle (11.5711, 6.39251);}
	\end{tikzpicture}
	\ExecuteMetaData[code/SN5.tex]{inter}
	\pause
	\ExecuteMetaData[code/SN5.tex]{inter-rename}
	\pause
	\ExecuteMetaData[code/SN5.tex]{adequacy-rename}
\end{frame}

\begin{frame}{Approach 5}
	\ExecuteMetaData[code/SN5.tex]{subst-split}
	\ExecuteMetaData[code/SN5.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Prueba para Sistema I}
	\ExecuteMetaData[code/strong_norm.tex]{SN}
	\pause
	\ExecuteMetaData[code/strong_norm.tex]{sn-star}
\end{frame}

\begin{frame}{Prueba para Sistema I}
	\ExecuteMetaData[code/strong_norm.tex]{lemma-iso-type}
\end{frame}

\begin{frame}{Caso \textsc{comm}}
	\ExecuteMetaData[code/strong_norm.tex]{iso-comm}
\end{frame}

\begin{frame}{Caso \textsc{curry}}
	\[ \lambda x^A. \lambda y^B. t \rightleftarrows \lambda z^{A \times B}. t[\pi_A(z)/x, \pi_B(z)/y] \]
	\[ \forall u_1, u_2 \in SN \Longrightarrow t[u_1/x, u_2/y] \in SN \]
	
	\[ \lambda z. t[\pi_A(z)/x, \pi_B(z)/y]\]
	\[ \forall u \in SN \Longrightarrow (t[\pi_A(z)/x, \pi_B(z)/y])[u/z] = t[\pi_A(u)/x, \pi_B(u)/y] \in SN \]
	 
	\[ u_1 = \pi_A(u) \quad u_2 = \pi_B(u) \]
\end{frame}

\begin{frame}{Caso \textsc{curry}}
	\[ \lambda x^{A \times B}. t \rightleftarrows \lambda y^A. \lambda z^B. t[\langle y, z \rangle/x] \]
	\[ \forall u \in SN \Longrightarrow t[u/x] \in SN \]
	
	\[ \lambda y. \lambda z. t[\langle y, z \rangle/x]\]
	
	\[ \forall u_1,u_2 \in SN \Longrightarrow ((t[\langle y, z \rangle/x])[u_1/y])[u_2/z] = t[\langle u_1, u_2 \rangle/x] \in SN \]
	
	\[ (\lambda z. t[\langle y, z \rangle/x])[u_1/y] = \lambda z. t[\langle u_1, z \rangle/x] \]
	\[ (t[\langle u_1, z \rangle/x])[u_2/z] = t[\langle u_1, u_2 \rangle/x] \]
	
	\[ u = \langle u_1, u_2 \rangle \]
\end{frame}
