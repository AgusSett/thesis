
\begin{frame}{Normalización Fuerte}
	\begin{block}{Definición (SN)}
		Un término $s$ es fuertemente normalizante si todos sus reductos también lo son:

		\centering
		\begin{prooftree}
			\hypo{ \forall t. s \hookrightarrow t \implies t \in SN }
			\infer1{ s \in SN }
		\end{prooftree}
	\end{block}
	
	\pause
	
	\ExecuteMetaData[code/SN1.tex]{sn-def}
	
	%\ExecuteMetaData[code/SN3.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Ejemplos}
	\ExecuteMetaData[code/example.tex]{sn-1}
	\pause
	\ExecuteMetaData[code/example.tex]{sn-2}
	\pause
	\ExecuteMetaData[code/example.tex]{sn-3}
\end{frame}

\begin{frame}{Approach 1}
	Realizamos inducción directa sobre los términos:
	\begin{AgdaSuppressSpace}
		\ExecuteMetaData[code/SN1.tex]{strong-type}
		
		\pause
		
		\ExecuteMetaData[code/SN1.tex]{strong-proof}
	\end{AgdaSuppressSpace}
	
	Por H.I. sabemos que $SN$ vale para los subterminos...
	\pause
	
	Definimos algunos lemas para construir $SN$ para todo el término.
\end{frame}

\begin{frame}{Approach 1}
	Definimos una función auxiliar para realizar \textit{pattern matching} sobre el paso de reducción:

	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<2>{\draw[red,thick,rounded corners] (4.40972, 5.01036) rectangle (5.29167, 4.58964);
		\draw[red,thick,rounded corners] (4.23333, 4.20031) rectangle (5.715, 3.7417);}
		\only<3>{
		\draw[red,thick,rounded corners] (7.54944, 4.20031) rectangle (9.13694, 3.7417);}
	\end{tikzpicture}
	\ExecuteMetaData[code/SN1.tex]{lemma-abs}
	
	\pause
	$ step : t \hookrightarrow t' $
	
	\pause
	$ f\; step : SN\; t' $
	
	\pause
	$ \text{lemma-ƛ } (f\; step) : SN\; (ƛ\; t') $
\end{frame}

\begin{frame}{Approach 1}
	\ExecuteMetaData[code/SN1.tex]{lemma-app}
	\pause
	No podemos concluir nada sobre $t[b]$, de hecho, la substitución podría crear nuevos redexes dentro de $t$.
\end{frame}

\begin{frame}{Approach 1}
	El lema de introducción del par es simple...
	\ExecuteMetaData[code/SN1.tex]{lemma-prod}
\end{frame}

\begin{frame}{Approach 1}
	Pero la eliminación también da problemas:
	\ExecuteMetaData[code/SN1.tex]{lemma-proj}
\end{frame}

\begin{frame}{Approach 2}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\draw[red,thick,rounded corners] (2.2225, 6.63447) rectangle (2.92806, 6.24642);
	\end{tikzpicture}
	Definimos un $SN$ más general que añade un predicado sobre el término:
	\ExecuteMetaData[code/SN2.tex]{sn-star}
	\pause
	Es fácil ver que $SN^*$ implica $SN$:
	\ExecuteMetaData[code/SN2.tex]{sn-star-sn}
	\pause
	Luego definimos la \textbf{interpretación del término}:
	\ExecuteMetaData[code/SN2.tex]{inter}
	
	% La definición de la interpretacíon en un término particular refleja la estructura lógica de ese término de forma apropiada.
\end{frame}

\begin{frame}{Approach 2}
	La prueba queda divida en dos pasos.
	\pause
	Primero se prueba el teorema fundamental:
	\ExecuteMetaData[code/SN2.tex]{adequacy-type}
	
	\pause
	Luego es fácil probar $SN$:
	\ExecuteMetaData[code/SN2.tex]{strong-proof}
\end{frame}

\begin{frame}{Approach 2}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{
			\draw[red,thick,rounded corners] (3.81, 5.43369) rectangle (4.33917, 5.04988);
			\draw[red,thick,rounded corners] (7.72583, 5.43369) rectangle (8.96056, 5.04988);
		}
		\only<2>{
			\draw[red,thick,rounded corners] (6.77333, 1.59266) rectangle (7.47889, 1.2017);
			\draw[red,thick,rounded corners] (10.0894, 1.55447) rectangle (10.795, 1.16642);
		}
	\end{tikzpicture}
	\ExecuteMetaData[code/SN2.tex]{lemma-app}
	La interpretación de la abstracción es precisamente lo que permite probar el caso de la aplicación.
	\pause
	Del mismo modo, la interpretación del par resuelve el caso de la proyección.
	\ExecuteMetaData[code/SN2.tex]{lemma-proj}
\end{frame}

\begin{frame}{Approach 2}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<2>{\draw[red,thick,rounded corners] (5.18583, 5.11881) rectangle (7.47889, 4.6602);}
		\only<3>{\draw[red,thick,rounded corners] (7.79639, 3.14325) rectangle (9.03111, 2.57881);}
	\end{tikzpicture}
	Por otro lado, las introducciones ahora deben construir las interpretaciones.
	
	\pause
	El caso del par es simple:
	\ExecuteMetaData[code/SN2.tex]{lemma-prod}
	
	\pause
	Sin embargo, el caso de la abstracción es complejo:
	\ExecuteMetaData[code/SN2.tex]{lemma-abs}

\end{frame}

\begin{frame}{Approach 2}
	\ExecuteMetaData[code/SN2.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Approach 3}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{\draw[red,thick,rounded corners] (7.44361, 5.22336) rectangle (10.16, 4.80003);}
		\only<2>{\draw[red,thick,rounded corners] (11.9592, 5.22336) rectangle (12.8411, 4.80003);}
	\end{tikzpicture}

	Generalizamos el teorema fundamental, vamos a probar que vale para cualquier $t$ con cualquier substitución aplicada:
	\ExecuteMetaData[code/SN3.tex]{adequacy-type}
	\pause[3]
	\ExecuteMetaData[code/SN3.tex]{strong-proof}
\end{frame}


\begin{frame}{Approach 3}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{\draw[red,thick,rounded corners] (6.70278, 4.83659) rectangle (7.90222, 4.37797);}
	\end{tikzpicture}
	%\ExecuteMetaData[code/SN3.tex]{subst-split}
	
	\ExecuteMetaData[code/SN3.tex]{adequacy-proof}
	\pause
	Ahora el problema está en el caso de las variables, una substitución arbitraria podría ``romper'' el término.
\end{frame}

\begin{frame}{Approach 4}
	Definimos las \textbf{substituciones adecuadas}:
	\ExecuteMetaData[code/SN4.tex]{adequacy-subst}
	\pause
	En particular $ids$ es adecuada:
	\ExecuteMetaData[code/SN4.tex]{adequacy-ids}
	\pause
	El cons entre un término $SN$ y una subst. adecuada, también es adecuada:
	\ExecuteMetaData[code/SN4.tex]{adequacy-cons}
	\pause
	Nuevamente fortalecemos el teorema:
	\ExecuteMetaData[code/SN4.tex]{adequacy-type}
\end{frame}

\begin{frame}{Approach 4}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<3>{\draw[red,thick,rounded corners] (3.77472, 4.72) rectangle (5.60917, 4.35);}
	\end{tikzpicture}
	
	\ExecuteMetaData[code/SN4.tex]{adequacy-proof}
	\pause
	\ExecuteMetaData[code/SN4.tex]{strong-proof}
\end{frame}

\begin{frame}{Approach 4}
	La extensión de una subst. adecuada es también es adecuada:
	\ExecuteMetaData[code/SN4.tex]{adequacy-exts}
	\pause
	Los renombres preservan la propiedad $SN^*$:
	\ExecuteMetaData[code/SN4.tex]{sn-rename}
	\pause
	Los renombres preservan la interpretación:
	\ExecuteMetaData[code/SN4.tex]{inter-rename}
\end{frame}

\begin{frame}{Approach 5}
	\begin{tikzpicture}[overlay, remember picture, shift=(current page.south west)]
		\only<1>{\draw[red,thick,rounded corners] (8.64306, 6.63447) rectangle (11.5711, 6.14059);}
	\end{tikzpicture}

	Generalizamos la interpretación de la abstracción:
	\ExecuteMetaData[code/SN5.tex]{inter}
	\pause
	\ExecuteMetaData[code/SN5.tex]{inter-rename}
	\pause
	La composición entre un renombre y una subst. adecuada, también es adecuada::
	\ExecuteMetaData[code/SN5.tex]{adequacy-rename}
\end{frame}

\begin{frame}{Approach 5}
	%\ExecuteMetaData[code/SN5.tex]{subst-split}
	\ExecuteMetaData[code/SN5.tex]{adequacy-proof}
\end{frame}

\begin{frame}{Prueba para Sistema I}
	Definimos la $SN$ para la unión entre $\hookrightarrow$ y $\rightleftarrows$:
	\ExecuteMetaData[code/strong_norm.tex]{SN}
	\pause
	\ExecuteMetaData[code/strong_norm.tex]{sn-star}
\end{frame}

\begin{frame}{Prueba para Sistema I}
	Se agrega el caso en adequacy:
	\ExecuteMetaData[code/strong_norm.tex]{adecuacy-iso}
	\pause
	El caso de la congruencia es simple:
	\ExecuteMetaData[code/strong_norm.tex]{lemma-iso-type}
\end{frame}

\begin{frame}{Caso \textsc{comm}}
	Para las equivalencias, la idea es ``desarmar'' las hipótesis del lado izquierdo, y reconstruir $SN$ del lado derecho usando los lemas anteriores:
	\ExecuteMetaData[code/strong_norm.tex]{iso-comm}
\end{frame}

\begin{frame}{Caso \textsc{curry}}
	\[ \lambda x^A. \lambda y^B. t \rightleftarrows \lambda z^{A \times B}. t[\pi_A(z)/x, \pi_B(z)/y] \]
	\pause
	
	Por hipótesis sabemos:
	\[ \forall u_1, u_2 \in SN \Longrightarrow t[u_1/x, u_2/y] \in SN \]
	\pause
	
	Debemos probar:
	\[ \lambda z. t[\pi_A(z)/x, \pi_B(z)/y] \in SN \]
	\pause
	\[ \forall u \in SN \Longrightarrow (t[\pi_A(\textcolor{red}{z})/x, \pi_B(\textcolor{red}{z})/y])[u/\textcolor{red}{z}] \pause = t[\pi_A(u)/x, \pi_B(u)/y] \in SN \]
	 
	\pause
	Basta con instanciar la hipótesis usando:
	\[ u_1 = \pi_A(u) \quad u_2 = \pi_B(u) \]
\end{frame}

\begin{frame}{Caso \textsc{curry}}
	\[ \lambda x^{A \times B}. t \rightleftarrows \lambda y^A. \lambda z^B. t[\langle y, z \rangle/x] \]
	\pause
	
	Por hipótesis sabemos:
	\[ \forall u \in SN \Longrightarrow t[u/x] \in SN \]
	\pause
	
	Debemos probar:
	\[ \lambda y. \lambda z. t[\langle y, z \rangle/x] \in SN \]
	
	\pause
	\[ \forall u_1,u_2 \in SN \Longrightarrow ((t[\langle \textcolor{blue}{y}, \textcolor{red}{z} \rangle/x])[u_1/\textcolor{blue}{y}])[u_2/\textcolor{red}{z}] \pause = t[\langle u_1, u_2 \rangle/x] \in SN \]

	\pause
	Basta con instanciar la hipótesis usando:
	\[ u = \langle u_1, u_2 \rangle \]
\end{frame}
